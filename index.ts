// Использование Zod:
import { z } from 'zod';

const schema = z.object({
  name: z.string().min(3),
  age: z.number().int().positive(),
});

const data = { name: 'John', age: 30 };

try {
  schema.parse(data);
  console.log('Данные прошли валидацию');
} catch (error) {
  console.error('Ошибка валидации:', error.errors);
}


// Использование Yup:
import * as yup from 'yup';

const schema = yup.object().shape({
  name: yup.string().min(3),
  age: yup.number().integer().positive(),
});

const data = { name: 'John', age: 30 };

schema.validate(data)
  .then(() => console.log('Данные прошли валидацию'))
  .catch((error) => console.error('Ошибка валидации:', error.errors);



//  Причины использования


1. Синтаксис:

- Zod: Использует простой и лаконичный синтаксис, основанный на методах для создания и комбинирования схем данных.

- Yup: Требует цепочечных вызовов методов, что может привести к более громоздкому виду кода.

2. Типизация:

- Zod: Полностью совместим с TypeScript и автоматически генерирует типы данных из схем, обеспечивая статическую проверку типов.

- Yup: Придется дополнительно настраивать и поддерживать TypeScript-типы для валидационных схем.

3. Производительность:

- Zod: Имеет хорошую производительность, особенно при работе с большими объемами данных.

- Yup: Не всегда может проявлять оптимальную производительность при сложных валидациях.

4. Расширяемость:

- Zod: Предоставляет удобные инструменты для создания кастомных валидаторов, расширения схем и композиции валидаций.

- Yup: Может быть сложнее расширять за пределы стандартного функционала.

5. Сообщения об ошибках:

- Zod: Позволяет легко настраивать кастомные сообщения об ошибках для каждого полей проверки.

- Yup: Имеет ограниченные возможности для настройки сообщений об ошибках.



zod npm - https://www.npmjs.com/package/zod

yup npm - https://www.npmjs.com/package/yup